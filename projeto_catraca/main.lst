CCS PCM C Compiler, Version 5.015, 5967               14-mar-21 14:51

               Filename:   C:\Users\carlo\Desktop\sistema-catraca\projeto_catraca\main.lst

               ROM used:   1014 words (12%)
                           Largest free fragment is 2048
               RAM used:   26 (7%) at main() level
                           50 (14%) worst case
               Stack used: 8 locations (4 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   3A3
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.3
0028:  GOTO   02B
0029:  BTFSC  0B.0
002A:  GOTO   04C
002B:  MOVF   22,W
002C:  MOVWF  04
002D:  MOVF   23,W
002E:  MOVWF  77
002F:  MOVF   24,W
0030:  MOVWF  78
0031:  MOVF   25,W
0032:  MOVWF  79
0033:  MOVF   26,W
0034:  MOVWF  7A
0035:  MOVF   27,W
0036:  BSF    03.6
0037:  MOVWF  0D
0038:  BCF    03.6
0039:  MOVF   28,W
003A:  BSF    03.6
003B:  MOVWF  0F
003C:  BCF    03.6
003D:  MOVF   29,W
003E:  BSF    03.6
003F:  MOVWF  0C
0040:  BCF    03.6
0041:  MOVF   2A,W
0042:  BSF    03.6
0043:  MOVWF  0E
0044:  BCF    03.6
0045:  MOVF   20,W
0046:  MOVWF  0A
0047:  SWAPF  21,W
0048:  MOVWF  03
0049:  SWAPF  7F,F
004A:  SWAPF  7F,W
004B:  RETFIE
004C:  BCF    0A.3
004D:  BCF    0A.4
004E:  GOTO   0F0
.................... #include <main.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
004F:  BCF    0A.0
0050:  BCF    0A.1
0051:  BCF    0A.2
0052:  ADDWF  02,F
0053:  RETLW  28
0054:  RETLW  0F
0055:  RETLW  01
0056:  RETLW  06
0057:  BCF    0A.0
0058:  BCF    0A.1
0059:  BCF    0A.2
005A:  ADDWF  02,F
005B:  RETLW  00
005C:  RETLW  00
*
0254:  MOVF   0B,W
0255:  MOVWF  41
0256:  BCF    0B.7
0257:  BSF    03.5
0258:  BSF    03.6
0259:  BSF    0C.7
025A:  BSF    0C.0
025B:  NOP
025C:  NOP
025D:  BCF    03.5
025E:  BCF    03.6
025F:  BTFSC  41.7
0260:  BSF    0B.7
0261:  BTFSC  03.0
0262:  GOTO   28B
0263:  BSF    03.6
0264:  MOVF   0C,W
0265:  ANDLW  7F
0266:  BCF    03.6
0267:  MOVWF  41
0268:  BSF    03.6
0269:  MOVF   0D,W
026A:  BCF    03.6
026B:  MOVWF  42
026C:  BSF    03.6
026D:  MOVF   0F,W
026E:  BCF    03.6
026F:  MOVWF  43
0270:  MOVF   41,W
0271:  MOVWF  44
0272:  CALL   0B9
0273:  MOVF   42,W
0274:  BSF    03.6
0275:  MOVWF  0D
0276:  BCF    03.6
0277:  MOVF   43,W
0278:  BSF    03.6
0279:  MOVWF  0F
027A:  BCF    03.6
027B:  MOVF   0B,W
027C:  MOVWF  44
027D:  BCF    0B.7
027E:  BSF    03.5
027F:  BSF    03.6
0280:  BSF    0C.7
0281:  BSF    0C.0
0282:  NOP
0283:  NOP
0284:  BCF    03.5
0285:  BCF    03.6
0286:  BTFSC  44.7
0287:  BSF    0B.7
0288:  DECFSZ 40,F
0289:  GOTO   28B
028A:  GOTO   2AA
028B:  BSF    03.6
028C:  RLF    0C,W
028D:  RLF    0E,W
028E:  ANDLW  7F
028F:  BCF    03.6
0290:  MOVWF  41
0291:  BSF    03.6
0292:  MOVF   0D,W
0293:  BCF    03.6
0294:  MOVWF  42
0295:  BSF    03.6
0296:  MOVF   0F,W
0297:  BCF    03.6
0298:  MOVWF  43
0299:  MOVF   41,W
029A:  MOVWF  44
029B:  CALL   0B9
029C:  MOVF   42,W
029D:  BSF    03.6
029E:  MOVWF  0D
029F:  BCF    03.6
02A0:  MOVF   43,W
02A1:  BSF    03.6
02A2:  MOVWF  0F
02A3:  INCF   0D,F
02A4:  BTFSC  03.2
02A5:  INCF   0F,F
02A6:  BCF    03.0
02A7:  BCF    03.6
02A8:  DECFSZ 40,F
02A9:  GOTO   254
*
02AD:  MOVF   00,F
02AE:  BTFSC  03.2
02AF:  GOTO   2C2
02B0:  CLRF   41
02B1:  MOVF   04,W
02B2:  MOVWF  40
02B3:  BCF    41.0
02B4:  BTFSC  03.7
02B5:  BSF    41.0
02B6:  MOVF   00,W
02B7:  MOVWF  44
02B8:  CALL   0B9
02B9:  MOVF   40,W
02BA:  MOVWF  04
02BB:  BCF    03.7
02BC:  BTFSC  41.0
02BD:  BSF    03.7
02BE:  INCF   04,F
02BF:  BTFSC  03.2
02C0:  INCF   05,F
02C1:  GOTO   2AD
*
02D9:  DATA 8C,29
02DA:  DATA 65,37
02DB:  DATA E8,30
02DC:  DATA 3A,10
02DD:  DATA A5,39
02DE:  DATA 00,00
02DF:  DATA 0C,10
02E0:  DATA D4,32
02E1:  DATA 63,36
02E2:  DATA 61,32
02E3:  DATA 6F,00
*
033F:  MOVF   0B,W
0340:  MOVWF  34
0341:  BCF    0B.7
0342:  BSF    03.5
0343:  BSF    03.6
0344:  BSF    0C.7
0345:  BSF    0C.0
0346:  NOP
0347:  NOP
0348:  BCF    03.5
0349:  BCF    03.6
034A:  BTFSC  34.7
034B:  BSF    0B.7
034C:  BSF    03.6
034D:  MOVF   0C,W
034E:  ANDLW  7F
034F:  BTFSC  03.2
0350:  GOTO   39F
0351:  BCF    03.6
0352:  MOVWF  34
0353:  BSF    03.6
0354:  MOVF   0D,W
0355:  BCF    03.6
0356:  MOVWF  35
0357:  BSF    03.6
0358:  MOVF   0F,W
0359:  BCF    03.6
035A:  MOVWF  36
035B:  CLRF   2B
035C:  BTFSC  0B.7
035D:  BSF    2B.7
035E:  BCF    0B.7
035F:  MOVF   34,W
0360:  MOVWF  44
0361:  CALL   0B9
0362:  BTFSC  2B.7
0363:  BSF    0B.7
0364:  MOVF   35,W
0365:  BSF    03.6
0366:  MOVWF  0D
0367:  BCF    03.6
0368:  MOVF   36,W
0369:  BSF    03.6
036A:  MOVWF  0F
036B:  BCF    03.6
036C:  MOVF   0B,W
036D:  MOVWF  37
036E:  BCF    0B.7
036F:  BSF    03.5
0370:  BSF    03.6
0371:  BSF    0C.7
0372:  BSF    0C.0
0373:  NOP
0374:  NOP
0375:  BCF    03.5
0376:  BCF    03.6
0377:  BTFSC  37.7
0378:  BSF    0B.7
0379:  BSF    03.6
037A:  RLF    0C,W
037B:  RLF    0E,W
037C:  ANDLW  7F
037D:  BTFSC  03.2
037E:  GOTO   39F
037F:  BCF    03.6
0380:  MOVWF  34
0381:  BSF    03.6
0382:  MOVF   0D,W
0383:  BCF    03.6
0384:  MOVWF  35
0385:  BSF    03.6
0386:  MOVF   0F,W
0387:  BCF    03.6
0388:  MOVWF  36
0389:  CLRF   2B
038A:  BTFSC  0B.7
038B:  BSF    2B.7
038C:  BCF    0B.7
038D:  MOVF   34,W
038E:  MOVWF  44
038F:  CALL   0B9
0390:  BTFSC  2B.7
0391:  BSF    0B.7
0392:  MOVF   35,W
0393:  BSF    03.6
0394:  MOVWF  0D
0395:  BCF    03.6
0396:  MOVF   36,W
0397:  BSF    03.6
0398:  MOVWF  0F
0399:  INCF   0D,F
039A:  BTFSC  03.2
039B:  INCF   0F,F
039C:  BCF    03.6
039D:  GOTO   33F
039E:  BSF    03.6
039F:  BCF    03.6
03A0:  BCF    0A.3
03A1:  BCF    0A.4
03A2:  GOTO   3C6 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
005D:  MOVLW  45
005E:  MOVWF  04
005F:  BCF    03.7
0060:  MOVF   00,W
0061:  BTFSC  03.2
0062:  GOTO   070
0063:  MOVLW  06
0064:  MOVWF  78
0065:  CLRF   77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 78,F
0069:  GOTO   065
006A:  MOVLW  7B
006B:  MOVWF  77
006C:  DECFSZ 77,F
006D:  GOTO   06C
006E:  DECFSZ 00,F
006F:  GOTO   063
0070:  RETURN
.................... #use FIXED_IO(B_outputs=PIN_B3,PIN_B2,PIN_B1,PIN_B0) 
....................  
....................  
.................... #include<stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
03AF:  BCF    03.5
03B0:  CLRF   2C
03B1:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulação de módulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fábio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e2		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variável de leitura 
.................... 	// lê os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dá um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lê os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
*
0071:  BTFSC  4C.0
0072:  GOTO   075
0073:  BCF    08.4
0074:  GOTO   076
0075:  BSF    08.4
0076:  BSF    03.5
0077:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
0078:  BCF    03.5
0079:  BTFSC  4C.1
007A:  GOTO   07D
007B:  BCF    08.5
007C:  GOTO   07E
007D:  BSF    08.5
007E:  BSF    03.5
007F:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
0080:  BCF    03.5
0081:  BTFSC  4C.2
0082:  GOTO   085
0083:  BCF    08.6
0084:  GOTO   086
0085:  BSF    08.6
0086:  BSF    03.5
0087:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
0088:  BCF    03.5
0089:  BTFSC  4C.3
008A:  GOTO   08D
008B:  BCF    08.7
008C:  GOTO   08E
008D:  BSF    08.7
008E:  BSF    03.5
008F:  BCF    08.7
.................... 	// dá um pulso na linha enable 
.................... 	output_high(lcd_enable); 
0090:  BCF    09.1
0091:  BCF    03.5
0092:  BSF    09.1
.................... 	output_low(lcd_enable); 
0093:  BSF    03.5
0094:  BCF    09.1
0095:  BCF    03.5
0096:  BCF    09.1
0097:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
0098:  BSF    03.5
0099:  BCF    09.2
009A:  BCF    03.5
009B:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
009C:  MOVF   49,F
009D:  BTFSS  03.2
009E:  GOTO   0A1
009F:  BCF    09.2
00A0:  GOTO   0A2
00A1:  BSF    09.2
00A2:  BSF    03.5
00A3:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
00A4:  MOVLW  A6
00A5:  MOVWF  77
00A6:  DECFSZ 77,F
00A7:  GOTO   0A6
00A8:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
00A9:  BCF    09.1
00AA:  BCF    03.5
00AB:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
00AC:  SWAPF  4A,W
00AD:  MOVWF  4B
00AE:  MOVLW  0F
00AF:  ANDWF  4B,F
00B0:  MOVF   4B,W
00B1:  MOVWF  4C
00B2:  CALL   071
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
00B3:  MOVF   4A,W
00B4:  ANDLW  0F
00B5:  MOVWF  4B
00B6:  MOVWF  4C
00B7:  CALL   071
00B8:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
*
02E4:  BSF    03.5
02E5:  BCF    08.4
02E6:  BCF    03.5
02E7:  BCF    08.4
.................... 	output_low(lcd_d5); 
02E8:  BSF    03.5
02E9:  BCF    08.5
02EA:  BCF    03.5
02EB:  BCF    08.5
.................... 	output_low(lcd_d6); 
02EC:  BSF    03.5
02ED:  BCF    08.6
02EE:  BCF    03.5
02EF:  BCF    08.6
.................... 	output_low(lcd_d7); 
02F0:  BSF    03.5
02F1:  BCF    08.7
02F2:  BCF    03.5
02F3:  BCF    08.7
.................... 	output_low(lcd_rs); 
02F4:  BSF    03.5
02F5:  BCF    09.2
02F6:  BCF    03.5
02F7:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
02F8:  BSF    03.5
02F9:  BCF    09.1
02FA:  BCF    03.5
02FB:  BCF    09.1
02FC:  CLRF   2B
02FD:  BTFSC  0B.7
02FE:  BSF    2B.7
02FF:  BCF    0B.7
.................... 	delay_ms(15); 
0300:  MOVLW  0F
0301:  MOVWF  45
0302:  CALL   05D
0303:  BTFSC  2B.7
0304:  BSF    0B.7
.................... 	// envia uma seqüência de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o módulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
0305:  MOVLW  01
0306:  MOVWF  34
0307:  MOVF   34,W
0308:  SUBLW  03
0309:  BTFSS  03.0
030A:  GOTO   31F
030B:  CLRF   2B
030C:  BTFSC  0B.7
030D:  BSF    2B.7
030E:  BCF    0B.7
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
030F:  MOVLW  03
0310:  MOVWF  4C
0311:  CALL   071
0312:  BTFSC  2B.7
0313:  BSF    0B.7
0314:  CLRF   2B
0315:  BTFSC  0B.7
0316:  BSF    2B.7
0317:  BCF    0B.7
.................... 		delay_ms(5); 
0318:  MOVLW  05
0319:  MOVWF  45
031A:  CALL   05D
031B:  BTFSC  2B.7
031C:  BSF    0B.7
031D:  INCF   34,F
031E:  GOTO   307
031F:  CLRF   2B
0320:  BTFSC  0B.7
0321:  BSF    2B.7
0322:  BCF    0B.7
.................... 	} 
.................... 	lcd_envia_nibble(2); 
0323:  MOVLW  02
0324:  MOVWF  4C
0325:  CALL   071
0326:  BTFSC  2B.7
0327:  BSF    0B.7
.................... 	// envia string de inicialização do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
0328:  CLRF   34
0329:  MOVF   34,W
032A:  SUBLW  03
032B:  BTFSS  03.0
032C:  GOTO   33C
032D:  MOVF   34,W
032E:  CALL   04F
032F:  MOVWF  35
0330:  CLRF   2B
0331:  BTFSC  0B.7
0332:  BSF    2B.7
0333:  BCF    0B.7
0334:  CLRF   49
0335:  MOVF   35,W
0336:  MOVWF  4A
0337:  CALL   098
0338:  BTFSC  2B.7
0339:  BSF    0B.7
033A:  INCF   34,F
033B:  GOTO   329
033C:  BCF    0A.3
033D:  BCF    0A.4
033E:  GOTO   3B6 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
00D3:  DECFSZ 46,W
00D4:  GOTO   0D6
00D5:  GOTO   0D9
....................    	endereco = lcd_seg_lin; 
00D6:  MOVLW  40
00D7:  MOVWF  47
00D8:  GOTO   0DA
....................    else 
....................    	endereco = 0; 
00D9:  CLRF   47
....................    endereco += x-1; 
00DA:  MOVLW  01
00DB:  SUBWF  45,W
00DC:  ADDWF  47,F
....................    lcd_envia_byte(0,0x80|endereco); 
00DD:  MOVF   47,W
00DE:  IORLW  80
00DF:  MOVWF  48
00E0:  CLRF   49
00E1:  MOVF   48,W
00E2:  MOVWF  4A
00E3:  CALL   098
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
00B9:  MOVF   44,W
00BA:  XORLW  0C
00BB:  BTFSC  03.2
00BC:  GOTO   0C7
00BD:  XORLW  06
00BE:  BTFSC  03.2
00BF:  GOTO   0CF
00C0:  XORLW  07
00C1:  BTFSC  03.2
00C2:  GOTO   0CF
00C3:  XORLW  05
00C4:  BTFSC  03.2
00C5:  GOTO   0E5
00C6:  GOTO   0EA
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
00C7:  CLRF   49
00C8:  MOVLW  01
00C9:  MOVWF  4A
00CA:  CALL   098
.................... 	  			delay_ms(2); 
00CB:  MOVLW  02
00CC:  MOVWF  45
00CD:  CALL   05D
.................... 				break; 
00CE:  GOTO   0EF
....................      case '\n'	: 
.................... 	  case '\r' 	:	lcd_pos_xy(1,2); 
00CF:  MOVLW  01
00D0:  MOVWF  45
00D1:  MOVLW  02
00D2:  MOVWF  46
.................... 	  			break; 
*
00E4:  GOTO   0EF
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
00E5:  CLRF   49
00E6:  MOVLW  10
00E7:  MOVWF  4A
00E8:  CALL   098
.................... 	  			break; 
00E9:  GOTO   0EF
....................      default	:	lcd_envia_byte(1,c); 
00EA:  MOVLW  01
00EB:  MOVWF  49
00EC:  MOVF   44,W
00ED:  MOVWF  4A
00EE:  CALL   098
.................... 	  			break; 
....................    } 
00EF:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posição do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lê o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
.................... #include "teclado.c" 
.................... unsigned char tc_tecla(){ 
*
00F2:  CLRF   40
....................     unsigned char k = 0; 
....................  
....................     output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
00F3:  MOVLW  F0
00F4:  BSF    03.5
00F5:  MOVWF  06
00F6:  BCF    03.5
00F7:  BCF    06.0
00F8:  BSF    03.5
00F9:  MOVWF  06
00FA:  BCF    03.5
00FB:  BSF    06.1
00FC:  BSF    03.5
00FD:  MOVWF  06
00FE:  BCF    03.5
00FF:  BSF    06.2
0100:  BSF    03.5
0101:  MOVWF  06
0102:  BCF    03.5
0103:  BSF    06.3
....................     delay_ms(20); 
0104:  MOVLW  14
0105:  MOVWF  45
0106:  CALL   05D
....................     if (input(PIN_B4) == 0){while(input(PIN_B4) == 0);k='1';}; 
0107:  MOVLW  F0
0108:  BSF    03.5
0109:  MOVWF  06
010A:  BCF    03.5
010B:  BTFSC  06.4
010C:  GOTO   115
010D:  MOVLW  F0
010E:  BSF    03.5
010F:  MOVWF  06
0110:  BCF    03.5
0111:  BTFSS  06.4
0112:  GOTO   10D
0113:  MOVLW  31
0114:  MOVWF  40
....................     if (input(PIN_B5) == 0){while(input(PIN_B5) == 0);k='4';}; 
0115:  MOVLW  F0
0116:  BSF    03.5
0117:  MOVWF  06
0118:  BCF    03.5
0119:  BTFSC  06.5
011A:  GOTO   123
011B:  MOVLW  F0
011C:  BSF    03.5
011D:  MOVWF  06
011E:  BCF    03.5
011F:  BTFSS  06.5
0120:  GOTO   11B
0121:  MOVLW  34
0122:  MOVWF  40
....................     if (input(PIN_B6) == 0){while(input(PIN_B6) == 0);k='7';}; 
0123:  MOVLW  F0
0124:  BSF    03.5
0125:  MOVWF  06
0126:  BCF    03.5
0127:  BTFSC  06.6
0128:  GOTO   131
0129:  MOVLW  F0
012A:  BSF    03.5
012B:  MOVWF  06
012C:  BCF    03.5
012D:  BTFSS  06.6
012E:  GOTO   129
012F:  MOVLW  37
0130:  MOVWF  40
....................     if (input(PIN_B7) == 0){while(input(PIN_B7) == 0);k='*';}; 
0131:  MOVLW  F0
0132:  BSF    03.5
0133:  MOVWF  06
0134:  BCF    03.5
0135:  BTFSC  06.7
0136:  GOTO   13F
0137:  MOVLW  F0
0138:  BSF    03.5
0139:  MOVWF  06
013A:  BCF    03.5
013B:  BTFSS  06.7
013C:  GOTO   137
013D:  MOVLW  2A
013E:  MOVWF  40
....................  
....................     output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
013F:  MOVLW  F0
0140:  BSF    03.5
0141:  MOVWF  06
0142:  BCF    03.5
0143:  BSF    06.0
0144:  BSF    03.5
0145:  MOVWF  06
0146:  BCF    03.5
0147:  BCF    06.1
0148:  BSF    03.5
0149:  MOVWF  06
014A:  BCF    03.5
014B:  BSF    06.2
014C:  BSF    03.5
014D:  MOVWF  06
014E:  BCF    03.5
014F:  BSF    06.3
....................     delay_ms(20); 
0150:  MOVLW  14
0151:  MOVWF  45
0152:  CALL   05D
....................     if (input(PIN_B4) == 0){while(input(PIN_B4) == 0);k='2';}; 
0153:  MOVLW  F0
0154:  BSF    03.5
0155:  MOVWF  06
0156:  BCF    03.5
0157:  BTFSC  06.4
0158:  GOTO   161
0159:  MOVLW  F0
015A:  BSF    03.5
015B:  MOVWF  06
015C:  BCF    03.5
015D:  BTFSS  06.4
015E:  GOTO   159
015F:  MOVLW  32
0160:  MOVWF  40
....................     if (input(PIN_B5) == 0){while(input(PIN_B5) == 0);k='5';}; 
0161:  MOVLW  F0
0162:  BSF    03.5
0163:  MOVWF  06
0164:  BCF    03.5
0165:  BTFSC  06.5
0166:  GOTO   16F
0167:  MOVLW  F0
0168:  BSF    03.5
0169:  MOVWF  06
016A:  BCF    03.5
016B:  BTFSS  06.5
016C:  GOTO   167
016D:  MOVLW  35
016E:  MOVWF  40
....................     if (input(PIN_B6) == 0){while(input(PIN_B6) == 0);k='8';}; 
016F:  MOVLW  F0
0170:  BSF    03.5
0171:  MOVWF  06
0172:  BCF    03.5
0173:  BTFSC  06.6
0174:  GOTO   17D
0175:  MOVLW  F0
0176:  BSF    03.5
0177:  MOVWF  06
0178:  BCF    03.5
0179:  BTFSS  06.6
017A:  GOTO   175
017B:  MOVLW  38
017C:  MOVWF  40
....................     if (input(PIN_B7) == 0){while(input(PIN_B7) == 0);k='0';}; 
017D:  MOVLW  F0
017E:  BSF    03.5
017F:  MOVWF  06
0180:  BCF    03.5
0181:  BTFSC  06.7
0182:  GOTO   18B
0183:  MOVLW  F0
0184:  BSF    03.5
0185:  MOVWF  06
0186:  BCF    03.5
0187:  BTFSS  06.7
0188:  GOTO   183
0189:  MOVLW  30
018A:  MOVWF  40
....................     
....................     output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
018B:  MOVLW  F0
018C:  BSF    03.5
018D:  MOVWF  06
018E:  BCF    03.5
018F:  BSF    06.0
0190:  BSF    03.5
0191:  MOVWF  06
0192:  BCF    03.5
0193:  BSF    06.1
0194:  BSF    03.5
0195:  MOVWF  06
0196:  BCF    03.5
0197:  BCF    06.2
0198:  BSF    03.5
0199:  MOVWF  06
019A:  BCF    03.5
019B:  BSF    06.3
....................     delay_ms(20); 
019C:  MOVLW  14
019D:  MOVWF  45
019E:  CALL   05D
....................     if (input(PIN_B4) == 0){while(input(PIN_B4) == 0);k='3';}; 
019F:  MOVLW  F0
01A0:  BSF    03.5
01A1:  MOVWF  06
01A2:  BCF    03.5
01A3:  BTFSC  06.4
01A4:  GOTO   1AD
01A5:  MOVLW  F0
01A6:  BSF    03.5
01A7:  MOVWF  06
01A8:  BCF    03.5
01A9:  BTFSS  06.4
01AA:  GOTO   1A5
01AB:  MOVLW  33
01AC:  MOVWF  40
....................     if (input(PIN_B5) == 0){while(input(PIN_B5) == 0);k='6';}; 
01AD:  MOVLW  F0
01AE:  BSF    03.5
01AF:  MOVWF  06
01B0:  BCF    03.5
01B1:  BTFSC  06.5
01B2:  GOTO   1BB
01B3:  MOVLW  F0
01B4:  BSF    03.5
01B5:  MOVWF  06
01B6:  BCF    03.5
01B7:  BTFSS  06.5
01B8:  GOTO   1B3
01B9:  MOVLW  36
01BA:  MOVWF  40
....................     if (input(PIN_B6) == 0){while(input(PIN_B6) == 0);k='9';}; 
01BB:  MOVLW  F0
01BC:  BSF    03.5
01BD:  MOVWF  06
01BE:  BCF    03.5
01BF:  BTFSC  06.6
01C0:  GOTO   1C9
01C1:  MOVLW  F0
01C2:  BSF    03.5
01C3:  MOVWF  06
01C4:  BCF    03.5
01C5:  BTFSS  06.6
01C6:  GOTO   1C1
01C7:  MOVLW  39
01C8:  MOVWF  40
....................     if (input(PIN_B7) == 0){while(input(PIN_B7) == 0);k='#';}; 
01C9:  MOVLW  F0
01CA:  BSF    03.5
01CB:  MOVWF  06
01CC:  BCF    03.5
01CD:  BTFSC  06.7
01CE:  GOTO   1D7
01CF:  MOVLW  F0
01D0:  BSF    03.5
01D1:  MOVWF  06
01D2:  BCF    03.5
01D3:  BTFSS  06.7
01D4:  GOTO   1CF
01D5:  MOVLW  23
01D6:  MOVWF  40
....................   
....................     output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
01D7:  MOVLW  F0
01D8:  BSF    03.5
01D9:  MOVWF  06
01DA:  BCF    03.5
01DB:  BSF    06.0
01DC:  BSF    03.5
01DD:  MOVWF  06
01DE:  BCF    03.5
01DF:  BSF    06.1
01E0:  BSF    03.5
01E1:  MOVWF  06
01E2:  BCF    03.5
01E3:  BSF    06.2
01E4:  BSF    03.5
01E5:  MOVWF  06
01E6:  BCF    03.5
01E7:  BCF    06.3
....................     delay_ms(20); 
01E8:  MOVLW  14
01E9:  MOVWF  45
01EA:  CALL   05D
....................     if (input(PIN_B4) == 0){while(input(PIN_B4) == 0);k='A';}; 
01EB:  MOVLW  F0
01EC:  BSF    03.5
01ED:  MOVWF  06
01EE:  BCF    03.5
01EF:  BTFSC  06.4
01F0:  GOTO   1F9
01F1:  MOVLW  F0
01F2:  BSF    03.5
01F3:  MOVWF  06
01F4:  BCF    03.5
01F5:  BTFSS  06.4
01F6:  GOTO   1F1
01F7:  MOVLW  41
01F8:  MOVWF  40
....................     if (input(PIN_B5) == 0){while(input(PIN_B5) == 0);k='B';}; 
01F9:  MOVLW  F0
01FA:  BSF    03.5
01FB:  MOVWF  06
01FC:  BCF    03.5
01FD:  BTFSC  06.5
01FE:  GOTO   207
01FF:  MOVLW  F0
0200:  BSF    03.5
0201:  MOVWF  06
0202:  BCF    03.5
0203:  BTFSS  06.5
0204:  GOTO   1FF
0205:  MOVLW  42
0206:  MOVWF  40
....................     if (input(PIN_B6) == 0){while(input(PIN_B6) == 0);k='C';}; 
0207:  MOVLW  F0
0208:  BSF    03.5
0209:  MOVWF  06
020A:  BCF    03.5
020B:  BTFSC  06.6
020C:  GOTO   215
020D:  MOVLW  F0
020E:  BSF    03.5
020F:  MOVWF  06
0210:  BCF    03.5
0211:  BTFSS  06.6
0212:  GOTO   20D
0213:  MOVLW  43
0214:  MOVWF  40
....................     if (input(PIN_B7) == 0){while(input(PIN_B7) == 0);k='D';}; 
0215:  MOVLW  F0
0216:  BSF    03.5
0217:  MOVWF  06
0218:  BCF    03.5
0219:  BTFSC  06.7
021A:  GOTO   223
021B:  MOVLW  F0
021C:  BSF    03.5
021D:  MOVWF  06
021E:  BCF    03.5
021F:  BTFSS  06.7
0220:  GOTO   21B
0221:  MOVLW  44
0222:  MOVWF  40
....................      
....................     if(!k)k=255; 
0223:  MOVF   40,F
0224:  BTFSS  03.2
0225:  GOTO   228
0226:  MOVLW  FF
0227:  MOVWF  40
....................      
....................     return k; 
0228:  MOVF   40,W
0229:  MOVWF  78
.................... } 
....................  
....................  
.................... unsigned char tmp; 
.................... char senha[4]; 
.................... int posicao = 0; 
....................  
....................  
.................... #INT_RB 
.................... void RB_isr(void)  
.................... { 
....................    disable_interrupts(INT_RB); 
*
00F0:  BCF    0B.3
....................    clear_interrupt(INT_RB); 
00F1:  BCF    0B.0
....................     
....................     tmp = tc_tecla(); 
*
022A:  MOVF   78,W
022B:  MOVWF  2E
....................     
....................    if(tmp!= 255){ 
022C:  INCFSZ 2E,W
022D:  GOTO   22F
022E:  GOTO   24B
....................      if(posicao > 3){ 
022F:  MOVF   33,W
0230:  SUBLW  03
0231:  BTFSC  03.0
0232:  GOTO   244
....................       // incluir na memoria antes de resetar 
....................          posicao = 0; 
0233:  CLRF   33
....................          senha = "\0"; 
0234:  CLRF   40
0235:  CLRF   41
0236:  MOVLW  2F
0237:  MOVWF  04
0238:  BCF    03.7
0239:  MOVF   40,W
023A:  ADDWF  04,F
023B:  MOVF   41,W
023C:  CALL   057
023D:  MOVWF  00
023E:  IORLW  00
023F:  BTFSC  03.2
0240:  GOTO   244
0241:  INCF   41,F
0242:  INCF   40,F
0243:  GOTO   236
....................      } 
....................       
....................      senha[posicao] = tmp; 
0244:  MOVLW  2F
0245:  ADDWF  33,W
0246:  MOVWF  04
0247:  BCF    03.7
0248:  MOVF   2E,W
0249:  MOVWF  00
....................      posicao++; 
024A:  INCF   33,F
....................    } 
....................     
....................    //printf(lcd_escreve, "\fValor: %c\n", valor);  
....................    printf(lcd_escreve, "\fSenha: %s", senha);  
024B:  MOVLW  D9
024C:  BSF    03.6
024D:  MOVWF  0D
024E:  MOVLW  02
024F:  MOVWF  0F
0250:  BCF    03.0
0251:  MOVLW  08
0252:  BCF    03.6
0253:  MOVWF  40
*
02AA:  MOVLW  2F
02AB:  MOVWF  04
02AC:  BCF    03.7
....................    clear_interrupt(INT_RB); 
*
02C2:  BCF    0B.0
....................    enable_interrupts(INT_RB); 
02C3:  BSF    0B.3
....................  
....................    output_low(PIN_B0); 
02C4:  MOVLW  F0
02C5:  BSF    03.5
02C6:  MOVWF  06
02C7:  BCF    03.5
02C8:  BCF    06.0
....................    output_low(PIN_B1); 
02C9:  BSF    03.5
02CA:  MOVWF  06
02CB:  BCF    03.5
02CC:  BCF    06.1
....................    output_low(PIN_B2); 
02CD:  BSF    03.5
02CE:  MOVWF  06
02CF:  BCF    03.5
02D0:  BCF    06.2
....................    output_low(PIN_B3); 
02D1:  BSF    03.5
02D2:  MOVWF  06
02D3:  BCF    03.5
02D4:  BCF    06.3
02D5:  BCF    0B.0
02D6:  BCF    0A.3
02D7:  BCF    0A.4
02D8:  GOTO   02B
.................... } 
....................  
.................... void main() 
*
03A3:  MOVF   03,W
03A4:  ANDLW  1F
03A5:  MOVWF  03
03A6:  CLRF   33
03A7:  BSF    03.5
03A8:  BSF    1F.0
03A9:  BSF    1F.1
03AA:  BSF    1F.2
03AB:  BCF    1F.3
03AC:  MOVLW  07
03AD:  MOVWF  1C
03AE:  BCF    03.7
.................... { 
....................    port_B_pullups(0xFF); 
*
03B2:  BSF    03.5
03B3:  BCF    01.7
....................     
....................    lcd_ini(); 
03B4:  BCF    03.5
03B5:  GOTO   2E4
03B6:  CLRF   2B
03B7:  BTFSC  0B.7
03B8:  BSF    2B.7
03B9:  BCF    0B.7
....................    delay_ms(10); 
03BA:  MOVLW  0A
03BB:  MOVWF  45
03BC:  CALL   05D
03BD:  BTFSC  2B.7
03BE:  BSF    0B.7
....................   
....................    printf(lcd_escreve, "\f Teclado"); 
03BF:  MOVLW  DF
03C0:  BSF    03.6
03C1:  MOVWF  0D
03C2:  MOVLW  02
03C3:  MOVWF  0F
03C4:  BCF    03.6
03C5:  GOTO   33F
....................    delay_ms(1000); 
03C6:  MOVLW  04
03C7:  MOVWF  34
03C8:  CLRF   2B
03C9:  BTFSC  0B.7
03CA:  BSF    2B.7
03CB:  BCF    0B.7
03CC:  MOVLW  FA
03CD:  MOVWF  45
03CE:  CALL   05D
03CF:  BTFSC  2B.7
03D0:  BSF    0B.7
03D1:  DECFSZ 34,F
03D2:  GOTO   3C8
....................     
....................    enable_interrupts(INT_RB); 
03D3:  BSF    0B.3
....................    enable_interrupts(GLOBAL); 
03D4:  MOVLW  C0
03D5:  IORWF  0B,F
....................    output_low(PIN_B0);output_low(PIN_B1);output_low(PIN_B2);output_low(PIN_B3); 
03D6:  MOVLW  F0
03D7:  BSF    03.5
03D8:  MOVWF  06
03D9:  BCF    03.5
03DA:  BCF    06.0
03DB:  BSF    03.5
03DC:  MOVWF  06
03DD:  BCF    03.5
03DE:  BCF    06.1
03DF:  BSF    03.5
03E0:  MOVWF  06
03E1:  BCF    03.5
03E2:  BCF    06.2
03E3:  BSF    03.5
03E4:  MOVWF  06
03E5:  BCF    03.5
03E6:  BCF    06.3
....................    
....................  
....................    while(TRUE){ 
....................       
....................       delay_ms(1000); 
03E7:  MOVLW  04
03E8:  MOVWF  34
03E9:  CLRF   2B
03EA:  BTFSC  0B.7
03EB:  BSF    2B.7
03EC:  BCF    0B.7
03ED:  MOVLW  FA
03EE:  MOVWF  45
03EF:  CALL   05D
03F0:  BTFSC  2B.7
03F1:  BSF    0B.7
03F2:  DECFSZ 34,F
03F3:  GOTO   3E9
03F4:  GOTO   3E7
....................    } 
.................... } 
03F5:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
